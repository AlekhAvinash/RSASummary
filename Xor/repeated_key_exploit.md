# Exploiting Repeated Key
The Repeated key at first glance might seem like a robust method of encryption. But there are a couple of ways to retrieve the data without knowledge of the key.

## Bruteforce
Just like a single byte xor can be broken by trying all possible keys we can break the system. When we move to repeated key xor, this attack gets harder. In a single byte Xor there are only 128 possible keys. If the repeating key size is 2 then the total possible keys (aka keyspace) increases to 128 * 128. This exponential increase in keyspace makes brute-force methods and inefficient exploit(particularly if the key size is unknown).

## Hamming Distance + Frequency Analysis
Hamming distance essentially calculates the number of positions where the 2 bytes are nullified(same bytes occurred). A simple implementation of Hamming distance is:-
```py
	def ham_dist(str1, str2):
		a=[]
		for b1, b2 in zip(str1, str2):
			for bit in bin(b1 ^ b2)[2:]:
				a.append(int(bit))
		return sum(a)
```
Frequency Analysis is, as the name suggests, the number of times a character has been repeated throughout the text. Here's an implementation of frequency analysis:-
```py
	def frequency_analysis(input_bytes):
		char_dict = {}
		for i in input_bytes.lower():
			if bytes([i]) not in char_dict:
				char_dict[bytes([i])] = 1
			else:
				char_dict[bytes([i])] += 1
		return char_dict
```
One of the problems encountered in the brute-force method was that; in most cases, the attacker has no knowledge of the key size. This problem is overcome by utilizing the unique property of XORs. When a value is XORed with itself the result will always be zero. This also is true for blocks of the same bytes (since blocks are XORed one byte at a time). Therefore given a long enough ciphertext, one can split the blocks to selected lengths and calculate the hamming distance of various distances. Since plaintext is unlikely to be repeated at small intervals the chances of plaintext blocks to coincide are minimal. Knowing this we can easily predict the distance with most hamming distance is the key's length. A simplified version of a key length calculator is given below:-
```py
	def key_length(cp):
		average_distances = {}
		for keysize in range(2,41):
			chunks = text_split(cp, keysize)
			# splits ciphertext(cp) to given keysizes
			distances = mul_chunk_ham_dist(chunks)
			# pairs up n chunks and calculate ham_dist of each pair
			average_distances[keysize] = sum(distances) / len(distances)
		return max_value(average_distances)
		# returns keysize with max value
```
With the key size known we can select characters at the repeating indices, group those characters together, and since all of those characters are XORed with the same character, the attacker can carry out a single byte XOR brute-force attack. But now a new problem arises. Since these characters are not in normal order they are not in readable English format. Here using frequency analysis we can come up with a ratio that can correctly predict if the resulting text is in English or not (provided the given ciphertext is long enough). So a repeated key XOR cipher can be broken.
```py
	def repeating_xor(cp):
		key = b''
		key_length = self.IC_key_length(cp)
		for i in range(key_length):
			block = index_blocks(cp)
			# splits cp text to blocks as said above. 
			key += single_xor(block)
			# returns single byte XOR key w/ freq. analysis and bruteforce methods
		return key
```

## Conclusion
The attacks mentioned above are 2 in a large list of methods in which the repeated key XORs are broken. But understanding the attack will allow one to understand the basis of crypto-based exploits. Although the 2nd method might seem like a faultless method, it is in many cases quite unreliable. If the input length is not sufficient enough the system would be next to useless. On the other hand, if the key length is really small in many situations brute-force could out-perform the hamming method.

[Here](https://github.com/AlekhAvinash/Writeups/blob/master/Xor/Xor.py) is a link to a simple implementation of repeated key xor exploit(with a few extra changes ;).










